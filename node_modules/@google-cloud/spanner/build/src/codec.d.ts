import { Big } from 'big.js';
import { common as p } from 'protobufjs';
import { google as spannerClient } from '../protos/protos';
export type Value = any;
export interface Field {
    name: string;
    value: Value;
}
export interface IProtoMessageParams {
    value: object;
    fullName: string;
    /**
     * Provide a First Class function that includes nested functions named
     * "encode" for serialization and "decode" for deserialization of the proto
     * message. The function should be sourced from the JS file generated by
     * protobufjs-cli for the proto message.
     */
    messageFunction?: Function;
}
export interface IProtoEnumParams {
    value: string | number;
    fullName: string;
    /**
     * An object containing enum string to id mapping.
     * @example: { POP: 0, JAZZ: 1, FOLK: 2, ROCK: 3 }
     *
     * The object should be sourced from the JS file generated by
     * protobufjs-cli for the proto message. Additionally, please review the
     * sample at {@link www.samples.com} for guidance.
     *
     * ToDo: Update the link
     */
    enumObject?: object;
}
export interface Json {
    [field: string]: Value;
}
export interface JSONOptions {
    wrapNumbers?: boolean;
    wrapStructs?: boolean;
    includeNameless?: boolean;
}
/**
 * Date-like object used to represent Cloud Spanner Dates. DATE types represent
 * a logical calendar date, independent of time zone. DATE values do not
 * represent a specific 24-hour period. Rather, a given DATE value represents a
 * different 24-hour period when interpreted in a different time zone. Because
 * of this, all values passed to {@link Spanner.date} will be interpreted as
 * local time.
 *
 * To represent an absolute point in time, use {@link Spanner.timestamp}.
 *
 * @see Spanner.date
 * @see https://cloud.google.com/spanner/docs/data-types#date-type
 *
 * @class
 * @extends Date
 *
 * @param {string|number} [date] String representing the date or number
 *     representing the year. If year is a number between 0 and 99, then year is
 *     assumed to be 1900 + year.
 * @param {number} [month] Number representing the month (0 = January).
 * @param {number} [date] Number representing the date.
 *
 * @example
 * ```
 * Spanner.date('3-3-1933');
 * ```
 */
export declare class SpannerDate extends Date {
    constructor(dateString?: string);
    constructor(year: number, month: number, date: number);
    /**
     * Returns the date in ISO date format.
     * `YYYY-MM-DD`
     *
     * @returns {string}
     */
    toJSON(): string;
}
/**
 * Using an abstract class to simplify checking for wrapped numbers.
 *
 * @private
 */
declare abstract class WrappedNumber {
    value: string | number;
    abstract valueOf(): number;
}
/**
 * @typedef Float32
 * @see Spanner.float32
 */
export declare class Float32 extends WrappedNumber {
    value: number;
    constructor(value: number);
    valueOf(): number;
}
/**
 * @typedef Float
 * @see Spanner.float
 */
export declare class Float extends WrappedNumber {
    value: number;
    constructor(value: number);
    valueOf(): number;
}
/**
 * @typedef Int
 * @see Spanner.int
 */
export declare class Int extends WrappedNumber {
    value: string;
    constructor(value: string);
    valueOf(): number;
}
/**
 * @typedef Struct
 * @see Spanner.struct
 */
export declare class Struct extends Array<Field> {
    /**
     * Converts struct into a pojo (plain old JavaScript object).
     *
     * @param {JSONOptions} [options] JSON options.
     * @returns {object}
     */
    toJSON(options?: JSONOptions): Json;
    /**
     * Converts an array of fields to a struct.
     *
     * @private
     *
     * @param {object[]} fields List of struct fields.
     * @return {Struct}
     */
    static fromArray(fields: Field[]): Struct;
    /**
     * Converts a JSON object to a struct.
     *
     * @private
     *
     * @param {object} json Struct JSON.
     * @return {Struct}
     */
    static fromJSON(json: Json): Struct;
}
/**
 * @typedef Numeric
 * @see Spanner.numeric
 */
export declare class Numeric {
    value: string;
    constructor(value: string);
    valueOf(): Big;
    toJSON(): string;
}
/**
 * @typedef PGNumeric
 * @see Spanner.pgNumeric
 */
export declare class PGNumeric {
    value: string;
    constructor(pgValue: string | number);
    valueOf(): Big;
    toJSON(): string;
}
/**
 * @typedef ProtoMessage
 * @see Spanner.protoMessage
 */
export declare class ProtoMessage {
    value: Buffer;
    fullName: string;
    messageFunction?: Function;
    constructor(protoMessageParams: IProtoMessageParams);
    toJSON(): string;
}
/**
 * @typedef ProtoEnum
 * @see Spanner.protoEnum
 */
export declare class ProtoEnum {
    value: string;
    fullName: string;
    enumObject?: object;
    constructor(protoEnumParams: IProtoEnumParams);
    toJSON(): string;
}
/**
 * @typedef PGJsonb
 * @see Spanner.pgJsonb
 */
export declare class PGJsonb {
    value: object;
    constructor(pgValue: object | string);
    toString(): string;
}
/**
 * @typedef PGOid
 * @see Spanner.pgOid
 */
export declare class PGOid extends WrappedNumber {
    value: string;
    constructor(value: string);
    valueOf(): number;
}
/**
 * @typedef JSONOptions
 * @property {boolean} [wrapNumbers=false] Indicates if the numbers should be
 *     wrapped in Int/Float wrappers.
 * @property {boolean} [wrapStructs=false] Indicates if the structs should be
 *     wrapped in Struct wrapper.
 * @property {boolean} [includeNameless=false] Indicates if nameless columns
 *     should be included in the result. If true, nameless columns will be
 *     assigned the name '_{column_index}'.
 */
/**
 * Wherever a row or struct object is returned, it is assigned a "toJSON"
 * function. This function will generate the JSON for that row.
 *
 * @private
 *
 * @param {array} row The row to generate JSON for.
 * @param {JSONOptions} [options] JSON options.
 * @returns {object}
 */
declare function convertFieldsToJson(fields: Field[], options?: JSONOptions): Json;
/**
 * Re-decode after the generic gRPC decoding step.
 *
 * @private
 *
 * @param {*} value Value to decode
 * @param {object[]} type Value type object.
 * @param columnMetadata Optional parameter to deserialize data
 * @returns {*}
 */
declare function decode(value: Value, type: spannerClient.spanner.v1.Type, columnMetadata?: object): Value;
/**
 * Encode a value in the format the API expects.
 *
 * @private
 *
 * @param {*} value The value to be encoded.
 * @returns {object} google.protobuf.Value
 */
declare function encode(value: Value): p.IValue;
/**
 * Conveniece Type object that simplifies specifying the data type, the array
 * child type and/or struct fields.
 *
 * @private
 */
export interface Type {
    type: string;
    fields?: FieldType[];
    child?: Type;
    fullName?: string;
}
interface FieldType extends Type {
    name: string;
}
/**
 * @typedef {ParamType} StructField
 * @property {string} name The name of the field.
 */
/**
 * @typedef {object} ParamType
 * @property {string} type The param type. Must be one of the following:
 *     - float32
 *     - float64
 *     - int64
 *     - numeric
 *     - bool
 *     - string
 *     - bytes
 *     - json
 *     - proto
 *     - enum
 *     - timestamp
 *     - date
 *     - struct
 *     - array
 * @property {StructField[]} [fields] **For struct types only**. Type
 *     definitions for the individual fields.
 * @property {string|ParamType} [child] **For array types only**. The array
 *     element type.
 */
/**
 * Get the corresponding Spanner data type for the provided value.
 *
 * @private
 *
 * @param {*} value - The value.
 * @returns {object}
 *
 * @example
 * ```
 * codec.getType(NaN);
 * // {type: 'float64'}
 * ```
 */
declare function getType(value: Value): Type;
/**
 * Converts a value to google.protobuf.ListValue
 *
 * @private
 *
 * @param {*} value The value to convert.
 * @returns {object}
 */
declare function convertToListValue<T>(value: T): p.IListValue;
/**
 * Converts milliseconds to google.protobuf.Timestamp
 *
 * @private
 *
 * @param {number} ms The milliseconds to convert.
 * @returns {object}
 */
declare function convertMsToProtoTimestamp(ms: number): spannerClient.protobuf.ITimestamp;
/**
 * Converts google.protobuf.Timestamp to Date object.
 *
 * @private
 *
 * @param {object} timestamp The protobuf timestamp.
 * @returns {Date}
 */
declare function convertProtoTimestampToDate({ nanos, seconds, }: p.ITimestamp): Date;
/**
 * Encodes paramTypes into correct structure.
 *
 * @private
 *
 * @param {object|string} [config='unspecified'] Type config.
 * @return {object}
 */
declare function createTypeObject(friendlyType?: string | Type): spannerClient.spanner.v1.Type;
export declare const codec: {
    convertToListValue: typeof convertToListValue;
    convertMsToProtoTimestamp: typeof convertMsToProtoTimestamp;
    convertProtoTimestampToDate: typeof convertProtoTimestampToDate;
    createTypeObject: typeof createTypeObject;
    SpannerDate: typeof SpannerDate;
    Float32: typeof Float32;
    Float: typeof Float;
    Int: typeof Int;
    Numeric: typeof Numeric;
    PGNumeric: typeof PGNumeric;
    PGJsonb: typeof PGJsonb;
    ProtoMessage: typeof ProtoMessage;
    ProtoEnum: typeof ProtoEnum;
    PGOid: typeof PGOid;
    convertFieldsToJson: typeof convertFieldsToJson;
    decode: typeof decode;
    encode: typeof encode;
    getType: typeof getType;
    Struct: typeof Struct;
};
export {};
